# -*- coding: utf-8 -*-
"""Курсач по метаданным.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MgM7-sb6gTkr6UVVCIHgGggew_tvSAvn

### БИБЛИОТЕКИ ДЛЯ РАЗЛИЧНЫХ ТИПОВ ФАЙЛОВ

#### Hachoir3: подходит для фото, аудио, видео, офисных документов(doc, docx и pptx), текстовых файлов, архивов(zip,rar), exe

Данная библиотека имеет два встроенных инструмента:
*	hachoir-metadata: получение метаданных из двоичных файлов
*	hachoir-strip: изменение файла для удаления метаданных

Было выведено только 3 варианта извлечения метаданных, но без группирования

Вариант 1. Извлечение сплошного текста
"""

from hachoir.parser import createParser
from hachoir.metadata import extractMetadata

filename = "C:/Users/stece/Downloads/original.jpg"
parser = createParser(filename)
metadata = extractMetadata(parser)

for line in metadata.exportPlaintext():
    print(line)

"""Вариант 2. Извлечение с использованием функции и проверки на ошибку"""

from hachoir.core.error import error
from hachoir.parser import createParser
from hachoir.core.tools import makePrintable
from hachoir.metadata import extractMetadata
from hachoir.core.i18n import getTerminalCharset

# Get metadata for video file
def metadata_for(filename):

    parser = createParser(filename)
    if not parser:
        print("Unable to parse file")
        exit(1)
    try:
        metadata = extractMetadata(parser)
    except error as err:
        print("Metadata extraction error: %s" % err)
        metadata = None
    if not metadata:
        print("Unable to extract metadata")
        exit(1)

    text = metadata.exportPlaintext()
    #charset = getTerminalCharset()
    #for line in text:
        #print(makePrintable(line, charset))

    return metadata

pathname = "C:/Users/stece/Downloads/original.jpg"
meta = metadata_for(pathname)
print(meta)
#metadata = metaDataFile(videoPath)
#width = metadata.get('width')
#height = metadata.get('height')
#fps = metadata.get('frame_rate')
width = meta.get('width')
print(width)
#meta.set('height', '1300')
height = meta.get('height')
print(height)

"""Вариант 3. Извлечение отдельно тегов и их значений"""

from collections import defaultdict
from hachoir.metadata import metadata
from hachoir.parser import createParser

# using this example http://archive.org/details/WorkToFishtestwmv
filename = 'C:/Users/stece/Downloads/videoplayback.mp4'
parser = createParser(filename)

# See what keys you can extract
#for k,v in metadata.extractMetadata(parser)._Metadata__data.iteritems():
    #if v.values:
        #print(v.key, v.values[0].value)

# Turn the tags into a defaultdict
metalist = metadata.extractMetadata(parser).exportPlaintext()
meta = {}
for item in metalist:
    if item.endswith(':'):
        #k = item[:-1]
        continue
    else:
        tag = item.split(': ')[0]
        tag = tag[2:]
        value = item.split(': ')[1]
        meta[tag] = value

print(meta['Image width']) # 320 pixels

"""#### Pymdeco: подходит для фото, аудио, видео, exe

Данная библиотека считается устаревшей, не функционирует

Был выведен только 1 вариант извлечения метаданных, но без группирования

Вариант 1. Извлечение метаданных
"""

from pymdeco import services
srv = services.FileMetadataService()

meta = srv.get_metadata('original.jpg')
print(meta.to_json(indent=2)) # to pretty print the metadata

"""#### Fileinfo: подходит для аудио, pdf, exe

Данная библиотека считается устаревшей, не функционирует

Была выведена только библиотека

Вариант 1. Библиотека
"""

from fileinfo import FileInfo

"""#### Tinytag: подходит для аудио, видео

Данная библиотека имеет встроенный инструмент:
*	TinyTag: чтения музыкальных метаданных

Было выведено только 4 варианта извлечения метаданных, но без группирования

Вариант 1. Извлечение метаданных
"""

from tinytag import TinyTag

filename3 = "C:/Users/stece/Downloads/XXXTENTACION - BAD.mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
tag = TinyTag.get(filename3, image=True)
print(tag)

"""Вариант 2. Извлечение метаданных с добавлением пустых тегов"""

from tinytag import TinyTag

filename3 = "C:/Users/stece/Downloads/XXXTENTACION - BAD.mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
tag = TinyTag.get(filename3)
# make sure everthing returned (except length) is a string
for attribute in ['artist','album','title','track']:
  if getattr(tag, attribute) is None:
    setattr(tag, attribute, '')

"""Вариант 3. Извлечение метаданных MP3"""

# Python3 program to illustrate 
# accessing of audio metadata 
# using tinytag library 

# Import Tinytag method from 
# tinytag library 
from tinytag import TinyTag

# Pass the filename into the 
# Tinytag.get() method and store 
# the result in audio variable 
audio = TinyTag.get("C:/Users/stece/Downloads/XXXTENTACION - BAD.mp3")

# Use the attributes 
# and Display 
print("Title:" + audio.title)
print("Artist: " + audio.artist)
print("Genre:" + audio.genre)
print("Year Released: " + audio.year)
print("Bitrate:" + str(audio.bitrate) + " kBits/s")
print("Composer: " + audio.composer)
print("Filesize: " + str(audio.filesize) + " bytes")
print("AlbumArtist: " + audio.albumartist)
print("Duration: " + str(audio.duration) + " seconds")
print("TrackTotal: " + str(audio.track_total))

"""Вариант 4. Извлечение метаданных MP4"""

# Python3 program to illustrate 
# accessing of video metadata
# using tinytag library

# Import Tinytag method from
# tinytag library
from tinytag import TinyTag

# Pass the filename into the
# Tinytag.get() method and store
# the result in audio variable
video = TinyTag.get("C:/Users/stece/Downloads/videoplayback.mp4")

# Use the attributes
# and display
print("Title:" + video.title)
print("Artist: " + video.artist)
print("Genre:" + video.genre)
print("Year Released: " + video.year)
print("Bitrate:" + str(video.bitrate) + " kBits/s")
print("Composer: " + video.composer)
print("Filesize: " + str(video.filesize) + " bytes")
print("AlbumArtist: " + str(video.albumartist))
print("Duration: " + str(video.duration) + " seconds")
print("TrackTotal: " + str(video.track_total))

"""#### Mutagen: подходит для аудио, видео

Данная библиотека имеет 4 встроенных инструмента:
*	mutagen: обработкиа звуковых метаданных
* MP3: обработка метаданных в MP3-файлах
* MP4: обработка метаданных в MP4-файлах
* ID3: обработка ID3-метаданных

Было выведено 3 варианта извлечения, 2 варианта изменения и 2 варианта удаления метаданных, но без группирования

Вариант 1. Извлечение метаданных обширным способом
"""

from __future__ import print_function

import argparse
import json
import mutagen

def handle_id3(id3_file):
   id3_frames = {'TIT2': 'Title', 'TPE1': 'Artist', 'TALB': 'Album','TXXX':
      'Custom', 'TCON': 'Content Type', 'TDRL': 'Date released','COMM': 'Comments',
         'TDRC': 'Recording Date'}
   print("{:15} | {:15} | {:38} | {}".format("Frame", "Description","Text","Value"))
   print("-" * 85)
   
   for frames in id3_file.tags.values():
      frame_name = id3_frames.get(frames.FrameID, frames.FrameID)
      desc = getattr(frames, 'desc', "N/A")
      text = getattr(frames, 'text', ["N/A"])[0]
      value = getattr(frames, 'value', "N/A")
      
      if "date" in frame_name.lower():
         text = str(text)
      print("{:15} | {:15} | {:38} | {}".format(
         frame_name, desc, text, value))

def handle_mp4(mp4_file):
    cp_sym = u"\u00A9"
    qt_tag = {
      cp_sym + 'nam': 'Title', cp_sym + 'art': 'Artist',
      cp_sym + 'alb': 'Album', cp_sym + 'gen': 'Genre',
      'cpil': 'Compilation', cp_sym + 'day': 'Creation Date',
      'cnID': 'Apple Store Content ID', 'atID': 'Album Title ID',
      'plID': 'Playlist ID', 'geID': 'Genre ID', 'pcst': 'Podcast',
      'purl': 'Podcast URL', 'egid': 'Episode Global ID',
      'cmID': 'Camera ID', 'sfID': 'Apple Store Country',
      'desc': 'Description', 'ldes': 'Long Description'}


    print("{:22} | {}".format('Name', 'Value'))
    print("-" * 40)

    for name, value in mp4_file.items():
        tag_name = qt_tag.get(name, name)
        
        if isinstance(value, list):
            value = "; ".join([str(x) for x in value])
        print("{:22} | {}".format(tag_name, value))


if __name__ == '__main__':
   av_file = mutagen.File("C:\\Users\\stece\\Downloads\\videoplayback.mp4")
   strok = "C:\\Users\\stece\\Downloads\\videoplayback.mp4"
   file_ext = strok.rsplit('.', 1)[-1]
   
   if file_ext.lower() == 'mp3':
      handle_id3(av_file)
   elif file_ext.lower() == 'mp4':
      handle_mp4(av_file)

"""Вариант 2. Извлечение метаданных стандартным способом"""

import mutagen

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = mutagen.File(filename3)
#audio['TIT2'].text[0] = "eere"
#audio.save()
print(audio.keys())

"""Вариант 3. Извлечение метаданных с помощью MP3, MP4, ID3"""

from mutagen.mp3 import MP3
from mutagen.mp4 import MP4
from mutagen.id3 import ID3

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = MP3(filename3)
#audio['TIT2'].text[0] = "eere"
#audio.save()
print(audio.keys())

"""Вариант 4. Изменение метаданных путем прямого обращения"""

import mutagen

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = mutagen.File(filename3)
audio['TIT2'].text[0] = "ytytyytyy"
audio.save()
print(audio)

"""Вариант 5. Изменение метаданных путем прямого обращения с помощью MP3, MP4, ID3"""

from mutagen.mp3 import MP3
from mutagen.mp4 import MP4
from mutagen.id3 import ID3

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = MP3(filename3)
audio['TIT2'].text[0] = "eere"
audio.save()
print(audio)

"""Вариант 6. Удаление метаданных"""

import mutagen

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = mutagen.File(filename3)
audio.delete()
audio.save()
print(audio)

"""Вариант 7. Удаление метаданных с помощью MP3, MP4, ID3"""

from mutagen.mp3 import MP3
from mutagen.mp4 import MP4
from mutagen.id3 import ID3

filename3 = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
audio = MP3(filename3)
audio.delete()
audio.save()
print(audio)

"""### БИБЛИОТЕКИ ДЛЯ ОДНОРОДНЫХ ТИПОВ ФАЙЛОВ

#### 1. Изображение

##### Exifread: подходит для Exif и близких к нему форматов

Данная библиотека имеет встроенный инструмент:

*	exifread: извлечение метаданных Exif из файлов цифровых изображений

Был выведен только 1 вариант извлечения метаданных, но с группированием

Вариант 1. Извлечение группированных метаданных
"""

import exifread

with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    tags = exifread.process_file(f)
    print(tags["Image ImageWidth"])
    for k,v in tags.items():
        print(k + ":", v)

"""##### Exif: подходит для Exif и близких к нему форматов

Данная библиотека имеет несколько встроенных инструментов:

*	Image: извлечение изображения
* get: извлечение метаданных Exif
* set: изменение метаданных Exif
* delete: удаление метаданных Exif
* delete_all: удаление всех метаданных Exif

Было выведено 3 варианта извлечения, 3 варианта изменения и 2 варианта удаления метаданных, но без группирования

Вариант 1. Извлечение метаданных стандартным способом
"""

from exif import Image
with open("C:/Users/stece/Downloads/o.jpg", 'rb') as f:
    img2 = Image(f)
    print(img2.has_exif)
    print(img2.model)

"""Вариант 2. Извлечение метаданных через запись аттрибута"""

from exif import Image
with open("C:/Users/stece/Downloads/o.jpg", 'rb') as f:
    img2 = Image(f)
    print(img2['model'])

"""Вариант 3. Извлечение метаданных через функцию получения значения"""

from exif import Image
with open("C:/Users/stece/Downloads/o.jpg", 'rb') as f:
    img2 = Image(f)
    print(img2.get('model'))

"""Вариант 4. Изменение метаданных стандартным способом"""

from exif import Image
with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    im_b = f.read()
img2 = Image(im_b)
print(img2.has_exif)
print(dir(img2))
print(img2.model)
#img2.get('model')
#img2.set('model', 'other')
#img2.delete('model')
#img2.delete_all()
img2.model = "other"
print(img2.model)
with open("C:/Users/stece/Downloads/o.jpg", 'wb') as new_image_file:
    new_image_file.write(img2.get_file())
#with open('C:/Users/stece/Downloads/or.jpg', 'wb') as new_image_file:
        #new_image_file.write(img2.get_file())

"""Вариант 5. Изменение метаданных через запись аттрибута"""

from exif import Image
with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    im_b = f.read()
img2 = Image(im_b)
print(img2.has_exif)
print(dir(img2))
print(img2.model)
#img2.get('model')
#img2.set('model', 'other')
#img2.delete('model')
#img2.delete_all()
img2['model'] = "other"
print(img2.model)
with open("C:/Users/stece/Downloads/o.jpg", 'wb') as new_image_file:
    new_image_file.write(img2.get_file())
#with open('C:/Users/stece/Downloads/or.jpg', 'wb') as new_image_file:
        #new_image_file.write(img2.get_file())

"""Вариант 6. Изменение метаданных через функцию вставки значения"""

from exif import Image
with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    im_b = f.read()
img2 = Image(im_b)
print(img2.has_exif)
print(dir(img2))
print(img2.model)
#img2.get('model')
#img2.set('model', 'other')
#img2.delete('model')
#img2.delete_all()
img2.set('model', "other")
print(img2.model)
with open("C:/Users/stece/Downloads/o.jpg", 'wb') as new_image_file:
    new_image_file.write(img2.get_file())
#with open('C:/Users/stece/Downloads/or.jpg', 'wb') as new_image_file:
        #new_image_file.write(img2.get_file())

"""Вариант 7. Удаление метаданных через функцию удаления аттрибута"""

from exif import Image
with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    im_b = f.read()
img2 = Image(im_b)
print(img2.has_exif)
print(dir(img2))
print(img2.model)
#img2.get('model')
#img2.set('model', 'other')
#img2.delete('model')
#img2.delete_all()
img2.delete('artist')
with open("C:/Users/stece/Downloads/o.jpg", 'wb') as new_image_file:
    new_image_file.write(img2.get_file())
#with open('C:/Users/stece/Downloads/or.jpg', 'wb') as new_image_file:
        #new_image_file.write(img2.get_file())

"""Вариант 8. Удаление метаданных через функцию удаления всех аттрибутов"""

from exif import Image
with open("C:/Users/stece/Downloads/original.jpg","rb") as f:
    im_b = f.read()
img2 = Image(im_b)
print(img2.has_exif)
print(dir(img2))
print(img2.model)
#img2.get('model')
#img2.set('model', 'other')
#img2.delete('model')
#img2.delete_all()
img2.delete_all()
with open("C:/Users/stece/Downloads/o.jpg", 'wb') as new_image_file:
    new_image_file.write(img2.get_file())
#with open('C:/Users/stece/Downloads/or.jpg', 'wb') as new_image_file:
        #new_image_file.write(img2.get_file())

"""##### PIL: подходит для Exif и близких к нему форматов

Данная библиотека имеет два встроенных инструмента:

* Image: извлечение изображения
* getexif: извлечение метаданных Exif
* TAGS: получение тегов метаданных Exif

Был выведен только 1 вариант извлечения метаданных, но без группирования

Вариант 1. Извлечение метаданных
"""

from PIL import Image
from PIL.ExifTags import TAGS

# path to the image or video
imagename = "C:/Users/stece/Downloads/original.jpg"
# read the image data using PIL
image = Image.open(imagename)

# extract EXIF data
exifdata = image.getexif()

# iterating over all EXIF data fields
for tag_id in exifdata:
    # get the tag name, instead of human unreadable tag id
    tag = TAGS.get(tag_id, tag_id)
    data = exifdata.get(tag_id)
    # decode bytes
    if isinstance(data, bytes):
        data = data.decode()
    print(f"{tag:25}: {data}")

"""##### Pyexif: подходит для Exif и близких к нему форматов

Данная библиотека имеет несколько встроенных инструмента:

* load (filename) - получить данные Exif как dict
* dump (exif_dict) - получить Exif в байтах
* insert (exif_bytes, filename) - вставить Exif в JPEG или WebP
* remove (имя файла) - удаление Exif из JPEG или WebP
* transplant (filename, filename) - трансплантация Exif из JPEG в JPEG

Было выведено 1 вариант извлечения, 2 варианта изменения и 1 вариант удаления метаданных, но с группированием

Вариант 1. Извлечение метаданных стандартным способом
"""

import piexif

exif_dict = piexif.load("C:/Users/stece/Downloads/original.jpg")
for ifd in ("0th", "Exif", "GPS", "1st"):
 for tag in exif_dict[ifd]:
     print(ifd, piexif.TAGS[ifd][tag]["name"], exif_dict[ifd][tag])

"""Вариант 2. Изменение метаданных с помощью библиотеки PIL"""

from PIL import Image
import piexif
filename = "C:/Users/stece/Downloads/original.jpg"
im = Image.open(filename)
exif_dict = piexif.load(im.info["exif"])
# process im and exif_dict...
w, h = im.size
exif_dict["0th"][piexif.ImageIFD.XResolution] = (w, 1)
exif_dict["0th"][piexif.ImageIFD.YResolution] = (h, 1)
exif_bytes = piexif.dump(exif_dict)
#im.save(new_file, "jpeg", exif=exif_bytes)

"""Вариант 3. Изменение метаданных с помощью библиотеки PIL с проверкой"""

import piexif
from PIL import Image
from collections import defaultdict

img = Image.open('C:\\Users\\stece\\Downloads\\original.jpg')

try:
    exif_dict = piexif.load(img.info["exif"])
except KeyError:
    exif_dict = defaultdict(dict)
    exif_img = defaultdict(dict)
exif_dict['Exif'][piexif.ExifIFD.Flash] = 37

exif_bytes = piexif.dump(exif_dict)
img.save('C:\\Users\\stece\\Downloads\\out.jpg', "jpeg", exif=exif_bytes)

"""Вариант 4. Удаление метаданных с помощью функции полного удаления Exif-данных"""

import piexif

filename = "C:/Users/stece/Downloads/original.jpg"
piexif.remove(filename)

"""##### Pyexiv2: подходит для Exif, IPTC, XMP

Данная библиотека считается самой свежой и к тому же 2020 года, но выдает ошибки при установке

Имеется только 1 вариант извлечения метаданных
"""

from PIL import Image
import io
from pyexiv2 import ImageData
meta = pyexiv2.ImageData("C:/Users/stece/Downloads/original.jpg")
meta.read()
byteio = io.BytesIO(meta.buffer)
img = Image.open(byteio)
img.show()

"""##### OpenCV: подходит для изображений

Данная библиотека без Pyexiv (и то не факт) ни к чему не подходит, просто работает с изображениями

##### IPTCInfo: подходит для IPTC

Данная библиотека считается устаревшей, не функционирует

##### XMP Toolkit: подходит для XMP

Данная библиотека считается устаревшей, не функционирует

##### Simplekml: подходит для GPS

Данная библиотека позволяет генерировать KML

#### 2. Аудиофайлы

##### EyeD3: подходит для аудио

Данная библиотека имеет встроенный инструмент:

*	eyed3: извлечение метаданных аудиофайлов через доступ к тегам

Было выведено 1 вариант извлечения, 2 варианта изменения и 1 вариант удаления метаданных, но без группирования

Вариант 1. Извлечение метаданных через прямой доступ к тегам
"""

import eyed3

filename = "C:/Users/stece/Downloads/XXXTENTACION - BAD (1).mp3"
audiofile = eyed3.load(filename)
print(audiofile.tag.artist)
print(audiofile.tag.album)
print(audiofile.tag.album_artist)
print(audiofile.tag.title)
print(audiofile.tag.track_num)

print(dir(audiofile.tag))

"""Вариант 2. Изменение метаданных через прямой доступ к тегам"""

import eyed3

filename = "C:/Users/stece/Downloads/XXXTENTACION - BAD (1).mp3"
audiofile = eyed3.load(filename)
audiofile.tag.artist = "Token Entry"
audiofile.tag.album = "Free For All Comp LP"
audiofile.tag.album_artist = "Various Artists"
audiofile.tag.title = "The Edge"
audiofile.tag.track_num = 3
audiofile.tag.save()

print(audiofile)

"""Вариант 3. Изменение метаданных через функцию вставки значений"""

import eyed3

filename = "C:/Users/stece/Downloads/XXXTENTACION - BAD (1).mp3"
audiofile = eyed3.load(filename)
audiofile.tag._setAlbum('fggfdf')
audiofile.tag.save()

print(audiofile.tag.album)

"""Вариант 4. Удаление метаданных и всех тегов"""

import eyed3

filename = "C:/Users/stece/Downloads/XXXTENTACION - BAD (1).mp3"
audiofile = eyed3.load(filename)
audiofile.tag.remove(filename)

print(audiofile.tag.album)

"""##### Audio_Metadata: подходит для аудио

Данная библиотека имеет встроенный инструмент:

*	audio_metadata: извлечение метаданных аудиофайлов в структурированном формате

Был выведен только 1 вариант извлечения метаданных, но с группированием

Вариант 1. Извлечение метаданных в структурированном формате
"""

import audio_metadata

filename = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"
meta = audio_metadata.load(filename)
print(meta)

"""##### Id3reader: подходит для аудио

Данная библиотека считается устаревшей, не функционирует

Имеется только 1 вариант извлечения метаданных
"""

import id3reader

# Construct a reader from a file or filename.
id3r = id3reader.Reader('my_favorite.mp3')

# Ask the reader for ID3 values:
print(id3r.getValue('TT2'))

print(id3r.getValue('album'))
print(id3r.getValue('performer'))
print(id3r.getValue('title'))
print(id3r.getValue('track'))
print(id3r.getValue('year'))

"""##### Mpeg1audio: подходит для аудио

Данная библиотека считается устаревшей, не функционирует

Имеется только 1 вариант извлечения метаданных
"""

import mpeg1audio

filename = "C:/Users/stece/Downloads/XXXTENTACION - BAD (1).mp3"

try:
    mp3 = mpeg1audio.MPEGAudio(open(filename, 'rb'))
except mpeg1audio.MPEGAudioHeaderException:
    pass
else:
    print (mp3.duration)

"""##### Pydub: подходит для аудио

Данная библиотека считается самой свежой и к тому же 2020 года, но выдает ошибки при компиляции

Имеется только 1 вариант извлечения метаданных
"""

from pydub import AudioSegment

filename = "C:/Users/stece/Downloads/XXXtentacion - BAD (1).mp3"

song = AudioSegment.from_mp3(filename)
print(song)

# pydub does things in miliseconds
ten_seconds = 10 * 1000

first_10_seconds = song[:10000]

last_5_seconds = song[-5000:]

# boost volume by 6dB
beginning = first_10_seconds + 6

# reduce volume by 3dB
end = last_5_seconds - 3

without_the_middle = beginning + end

# song is not modified
backwards = song.reverse()

# 1.5 second crossfade
with_style = beginning.append(end, crossfade=1500)

# repeat the clip twice
do_it_over = with_style * 2

# 2 sec fade in, 3 sec fade out
awesome = do_it_over.fade_in(2000).fade_out(3000)

awesome.export("mashup.mp3", format="mp3")

"""#### 3. Видеофайлы

##### Youtube-extract: подходит для видео

Данная библиотека работает только с видео на Youtube-канале

##### Enzyme: подходит для видео

Данная библиотека считается устаревшей, функционирует с немногими форматами

Имеется только 1 вариант извлечения метаданных
"""

import enzyme

filenameMkv = "C:/Users/stece/Downloads/6IX9INE- GOOBA (Official Music Video).webm"

with open(filenameMkv, 'rb') as f:
    mkv = enzyme.MKV(f)

print(mkv)
print(mkv.info)
print(mkv.video_tracks)
print(mkv.audio_tracks)
print(mkv.subtitle_tracks)

"""##### FFmpeg: подходит для видео

Данная библиотека считается относительно свежей, не функционирует

Имеется только 1 вариант извлечения метаданных
"""

import ffmpeg

filename4 = "C:/Users/stece/Downloads/videoplayback.mp4"
filename69 = "C:/Users/stece/Downloads/6IX9INE- GOOBA (Official Music Video).webm"

input = ffmpeg.input(filename4)
audio = input.audio.filter("aecho", 0.8, 0.9, 1000, 0.3)
video = input.video.hflip()
#out = ffmpeg.output(audio, video, 'out.mp4')
print(audio)
print(video)

"""#### 4. PDF

##### PyPDF2: подходит для PDF, XMP

Данная библиотека имеет два встроенных инструмента:

*	getDocumentInfo: извлечение основных метаданных
* getXmpMetadata: извлечение метаданных XMP
* documentInfo: обновление основных метаданных

Было выведено 6 вариантов извлечения и 3 варианта изменения метаданных, но с группированием

Вариант 1. Извлечение основных метаданных путем прямого доступа к тегам с проверкой
"""

import datetime
from PyPDF2 import PdfFileReader
import sys

#filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"

pdf_file = PdfFileReader(filename2)
base = pdf_file.getDocumentInfo()

if base is None:
   print("No base metadata found in document.")
   sys.exit()

def custom_print(fmt_str, value):
   if isinstance(value, list):
      print(fmt_str.format(", ".join(value)))
   elif isinstance(value, dict):
      fmt_value = [":".join((k, v)) for k, v in value.items()]
      print(fmt_str.format(", ".join(value)))
   elif isinstance(value, str) or isinstance(value, bool):
      print(fmt_str.format(value))
   elif isinstance(value, bytes):
      print(fmt_str.format(value.decode()))
   elif isinstance(value, datetime.datetime):
      print(fmt_str.format(value.isoformat()))
   elif value is None:
      print(fmt_str.format("N/A"))
   else:
      print("warn: unhandled type {} found".format(type(value)))

custom_print("Title: {}", base.title)
custom_print("Creator(s): {}", base.creator)
custom_print("Subject: {}", base.subject)

"""Вариант 2. Извлечение метаданных XMP путем прямого доступа к тегам с проверкой"""

import datetime
from PyPDF2 import PdfFileReader
import sys

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = "C:/Users/stece/Downloads/График платежей.pdf"

pdf_file = PdfFileReader(filename1)
xmpm = pdf_file.getXmpMetadata()

if xmpm is None:
   print("No XMP metadata found in document.")
   sys.exit()

def custom_print(fmt_str, value):
   if isinstance(value, list):
      print(fmt_str.format(", ".join(value)))
   elif isinstance(value, dict):
      fmt_value = [":".join((k, v)) for k, v in value.items()]
      print(fmt_str.format(", ".join(value)))
   elif isinstance(value, str) or isinstance(value, bool):
      print(fmt_str.format(value))
   elif isinstance(value, bytes):
      print(fmt_str.format(value.decode()))
   elif isinstance(value, datetime.datetime):
      print(fmt_str.format(value.isoformat()))
   elif value is None:
      print(fmt_str.format("N/A"))
   else:
      print("warn: unhandled type {} found".format(type(value)))

custom_print("Title: {}", xmpm.dc_title)
custom_print("Creator(s): {}", xmpm.dc_creator)
custom_print("Contributors: {}", xmpm.dc_contributor)
custom_print("Subject: {}", xmpm.dc_subject)
custom_print("Description: {}", xmpm.dc_description)
custom_print("Created: {}", xmpm.xmp_createDate)
custom_print("Modified: {}", xmpm.xmp_modifyDate)
custom_print("Event Dates: {}", xmpm.dc_date)

if xmpm.custom_properties:
   print("Custom Properties:")
   
   for k, v in xmpm.custom_properties.items():
      print("\t{}: {}".format(k, v))

"""Вариант 3. Извлечение всех основных метаданных"""

import datetime
from PyPDF2 import PdfFileReader
import sys

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"

pdf_file = PdfFileReader(filename2)
base = pdf_file.getDocumentInfo()

print(base)

"""Вариант 4. Извлечение всех метаданных XMP с проверкой"""

import datetime
from PyPDF2 import PdfFileReader
import sys

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"

pdf_file = PdfFileReader(filename1)
xmpm = pdf_file.getXmpMetadata()

xmp_methods = ['custom_properties', 'dc_contributor',
                'dc_coverage', 'dc_creator',
                'dc_date', 'dc_description',
                'dc_format', 'dc_identifier',
                'dc_language', 'dc_publisher',
                'dc_relation', 'dc_rights',
                'dc_source', 'dc_subject',
                'dc_title', 'dc_type',
                'pdf_keywords', 'pdf_pdfversion',
                'pdf_producer', 'xmp_createDate',
                'xmp_creatorTool', 'xmp_metadataDate',
                'xmp_modifyDate', 'xmpmm_documentId',
                'xmpmm_instanceId']

xmpm_dict = {}
for i in xmp_methods:
    try:
        xmpm_dict[i] = getattr(xmpm, i)
    except:
        xmpm_dict[i] = ''

print(xmpm_dict)

"""Вариант 5. Извлечение всех основных метаданных итеративно"""

import datetime
from PyPDF2 import PdfFileReader
import sys

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"

pdf_file = PdfFileReader(filename2)
base = pdf_file.getDocumentInfo()

for data in base:
    print(data + ":", base[data])

"""Вариант 6. Извлечение всех метаданных XMP с проверкой итеративно"""

import datetime
from PyPDF2 import PdfFileReader
import sys

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"

pdf_file = PdfFileReader(filename1)
xmpm = pdf_file.getXmpMetadata()

xmp_methods = ['custom_properties', 'dc_contributor',
                'dc_coverage', 'dc_creator',
                'dc_date', 'dc_description',
                'dc_format', 'dc_identifier',
                'dc_language', 'dc_publisher',
                'dc_relation', 'dc_rights',
                'dc_source', 'dc_subject',
                'dc_title', 'dc_type',
                'pdf_keywords', 'pdf_pdfversion',
                'pdf_producer', 'xmp_createDate',
                'xmp_creatorTool', 'xmp_metadataDate',
                'xmp_modifyDate', 'xmpmm_documentId',
                'xmpmm_instanceId']

xmpm_dict = {}
for i in xmp_methods:
    try:
        xmpm_dict[i] = getattr(xmpm, i)
    except:
        xmpm_dict[i] = ''

for data in xmpm_dict:
    print(data + ":", xmpm_dict[data])

"""Вариант 7. Изменение основных метаданных путем перезаписи всех метаданных, в том числе и неизмененных"""

from PyPDF2 import PdfFileReader, PdfFileWriter

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

file_in = open(filename1, 'rb')
pdf_reader = PdfFileReader(file_in)
metadata = pdf_reader.getDocumentInfo()
#metadata.author.__setattr__ = "whoami"
#setattr(metadata, '/Author', "whoami")
#print(metadata)

pdf_writer = PdfFileWriter()
pdf_writer.appendPagesFromReader(pdf_reader)
#pdf_writer.addMetadata(metadata)
pdf_writer.addMetadata({
    '/Author': 'Someone',
    '/Title': 'PDF in Python'
})
file_out = open('C:/Users/stece/Downloads/new.pdf', 'wb')
pdf_writer.write(file_out)

file_in.close()
file_out.close()

"""Вариант 8. Изменение основных метаданных путем добавление отдельных метаданных"""

from PyPDF2 import PdfFileReader, PdfFileMerger

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

file_in = open(filename1, 'rb')
pdf_reader = PdfFileReader(file_in)
metadata = pdf_reader.getDocumentInfo()
#metadata.author.__setattr__ = "whoami"
#setattr(metadata, '/Author', "whoami")
#print(metadata)

pdf_merger = PdfFileMerger()
#pdf_merger.appendPagesFromReader(pdf_reader)
#pdf_writer.addMetadata(metadata)
pdf_merger.addMetadata({
    '/Author': 'Someone',
    '/Title': 'PDF in Python'
})
file_in.close()
file_out = open(filename1, 'wb')
pdf_merger.write(file_out)

file_out.close()

"""Вариант 9. Изменение основных метаданных путем обновления отдельных метаданных"""

from PyPDF2 import PdfFileReader, PdfFileWriter
from PyPDF2.generic import NameObject, createStringObject

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

file_in = open(filename1, 'rb')
pdf_reader = PdfFileReader(file_in)
writer = PdfFileWriter()
infoDict = writer._info.getObject()

info = pdf_reader.documentInfo
for key in info:
    infoDict.update({NameObject(key): createStringObject(info[key])})
    print(key + ":", info[key])

infoDict.update({NameObject('/Title'): createStringObject('whoami')})

fout = open('C:/Users/stece/Downloads/out.pdf', 'wb')

writer.write(fout)
file_in.close()

fout.close()

"""##### PDFMiner: подходит для PDF, XMP

Данная библиотека имеет встроенный инструмент:

*	PDFDocument: извлечение всех метаданных

Был выведен только 1 вариант извлечения метаданных (возможно имеются варианты изменения и удаления), но относительно с группированием

Вариант 1. Извлечение всех метаданных, используя дополнительный скрипт с парсингом
"""

from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
from pdfminer.pdftypes import resolve1
from live import xmp_to_dict

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
#filename3 = 'C:/Users/stece/Downloads/new.pdf'

fp = open(filename1, 'rb')
parser = PDFParser(fp)
doc = PDFDocument(parser)

#print(doc.catalog)  # The "Info" metadata

if 'Metadata' in doc.catalog:
    metadata = resolve1(doc.catalog['Metadata']).get_data()
    #print(xmp_to_dict(metadata))  # The raw XMP metadata

    meta = xmp_to_dict(metadata)
    print(meta.items())

#filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
#filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
#filename3 = 'C:/Users/stece/Downloads/new.pdf'

#!/usr/bin/env python
"""
 xmp.py
    ~~~~~~
 Parses XMP metadata from PDF files.
 By Matt Swain. Released under the MIT license.
"""
from collections import defaultdict
from xml.etree import ElementTree as ET
RDF_NS = '{http://www.w3.org/1999/02/22-rdf-syntax-ns#}'
XML_NS = '{http://www.w3.org/XML/1998/namespace}'
NS_MAP = {
    'http://www.w3.org/1999/02/22-rdf-syntax-ns#'    : 'rdf',
    'http://purl.org/dc/elements/1.1/'               : 'dc',
    'http://ns.adobe.com/xap/1.0/'                   : 'xap',
    'http://ns.adobe.com/pdf/1.3/'                   : 'pdf',
    'http://ns.adobe.com/xap/1.0/mm/'                : 'xapmm',
    'http://ns.adobe.com/pdfx/1.3/'                  : 'pdfx',
    'http://prismstandard.org/namespaces/basic/2.0/' : 'prism',
    'http://crossref.org/crossmark/1.0/'             : 'crossmark',
    'http://ns.adobe.com/xap/1.0/rights/'            : 'rights',
    'http://www.w3.org/XML/1998/namespace'           : 'xml'
}
class XmpParser(object):
    """Parser that converts an XMP string into a dictionary.
    Usage::
        parser = XmpParser(xmpstring)
        meta = parser.meta
    """
    def __init__(self, xmp):
        self.tree = ET.XML(xmp)
        self.rdftree = self.tree.find(RDF_NS+'RDF')
    @property
    def meta(self):
        """A dictionary of all the parsed metadata."""
        meta = defaultdict(dict)
        for desc in self.rdftree.findall(RDF_NS+'Description'):
            for el in desc.getchildren():
                ns, tag =  self._parse_tag(el)
                value = self._parse_value(el)
                meta[ns][tag] = value
        return dict(meta)
    def _parse_tag(self, el):
        """Extract the namespace and tag from an element."""
        ns = None
        tag = el.tag
        if tag[0] == "{":
            ns, tag = tag[1:].split('}',1)
            if ns in NS_MAP:
                ns = NS_MAP[ns]
        return ns, tag
    def _parse_value(self, el):
        """Extract the metadata value from an element."""
        if el.find(RDF_NS+'Bag') is not None:
            value = []
            for li in el.findall(RDF_NS+'Bag/'+RDF_NS+'li'):
                value.append(li.text)
        elif el.find(RDF_NS+'Seq') is not None:
            value = []
            for li in el.findall(RDF_NS+'Seq/'+RDF_NS+'li'):
                value.append(li.text)
        elif el.find(RDF_NS+'Alt') is not None:
            value = {}
            for li in el.findall(RDF_NS+'Alt/'+RDF_NS+'li'):
                value[li.get(XML_NS+'lang')] = li.text
        else:
            value = el.text
        return value
def xmp_to_dict(xmp):
    """Parse an XMP string into a dictionary."""
    return XmpParser(xmp).meta

"""##### PDFx: подходит для PDF, XMP

Данная библиотека имеет встроенный инструмент:

*	get_metadata: извлечение всех метаданных

Было выведено только 3 варианта извлечения метаданных (возможно имеются варианты изменения и удаления), но с группированием

Вариант 1. Извлечение всех метаданных
"""

import pdfx

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

pdf = pdfx.PDFx(filename1)
metadata = pdf.get_metadata()
print(metadata)

"""Вариант 2. Извлечение отдельных метаданных с проверкой"""

import pdfx

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

def check_if_exist(data):
    if data:
        if isinstance(data, list):
            return ', '.join(data)
        return data
    return None

pdf = pdfx.PDFx(filename1)
metadata = pdf.get_metadata()
# print(type(metadata))
# print(metadata['dc']['creator'])
# print(type(metadata['dc']['creator']))
# print(metadata['dc']['publisher'])
# print(metadata['dc']['identifier'])
# print(' '.join(metadata['dc']['subject']))
args = dict()
args['author'] = check_if_exist(metadata['dc']['creator'])
#args['publisher'] = check_if_exist(metadata['dc']['publisher'])
#args['doi'] = check_if_exist(metadata['dc']['identifier'])
#args['title'] = check_if_exist(metadata['dc']['title']['x-default'])
#args['subject'] = check_if_exist(metadata['dc']['subject'])
args['pages'] = check_if_exist(metadata['Pages'])
print(args)

"""Вариант 3. Извлечение отдельных метаданных итеративно"""

import pdfx

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

pdf = pdfx.PDFx(filename1)
metadata = pdf.get_metadata()
#print(metadata.items())
#print(metadata.keys())
#print(metadata.values())
#print(metadata.get('dc'))
#metadata.clear()
print(metadata.items())

for t in metadata.items():
    print(t)

"""##### Pycpdf: подходит для PDF, возможно XMP

Данная библиотека считается относительно свежей, не функционирует

Имеется только 1 вариант извлечения метаданных
"""

import pycpdf

pdf = pycpdf.PDF(open('file.pdf', 'rb').read())
if pdf.info and pdf.info.get('Title'):
    print('Title:', pdf.info['Title'])
#for pageno, page in enumerate(pdf.pages):
    #print('Page', pageno + 1)
    #print(page.text.translate(pycpdf.unicode_translations))

"""##### Pdfrw: подходит для PDF

Данная библиотека имеет 3 встроенных инструмента:

*	PdfReader: извлечение всех метаданных
* IndirectPdfDict: составление собственного списка метаданных для перезаписи метаданных
* PdfDict: составление собственного списка метаданных для обновления метаданных

Было выведено 3 варианта извлечения и 4 варианта изменения метаданных, но без группирования

Вариант 1. Извлечение отдельных метаданных путем прямого обращения к тегам без перекодирования
"""

from pdfrw import PdfReader, PdfWriter, PdfDict
import unicodedata

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

#def unicode_normalize(s):
    #return unicodedata.normalize('NFKD', s).encode('ascii', 'ignore')

pdf_reader = PdfReader(filename1)
print("Title:", pdf_reader.Info.Title)
print("Creator:", pdf_reader.Info.Creator)
print("CreationDate:", pdf_reader.Info.CreationDate)
print("ModDate:", pdf_reader.Info.ModDate)
print("Producer:", pdf_reader.Info.Producer)

"""Вариант 2. Извлечение отдельных метаданных путем прямого обращения к тегам с перекодированием"""

from pdfrw import PdfReader, PdfWriter, PdfDict
import unicodedata

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

def unicode_normalize(s):
    return unicodedata.normalize('NFKD', s).encode('ascii', 'ignore')

trailer = PdfReader(filename1)

# this statement is breaking pdfrw
trailer.Info.Creator = unicode_normalize(trailer.Info.Creator.decode())
print(trailer.Info)

"""Вариант 3. Извлечение всех метаданных без перекодирования"""

from pdfrw import PdfReader, PdfWriter, PdfDict
import unicodedata

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

#def unicode_normalize(s):
    #return unicodedata.normalize('NFKD', s).encode('ascii', 'ignore')

pdf_reader = PdfReader(filename1)
print(pdf_reader.keys())
print(pdf_reader.Info.items())
for t in pdf_reader.Info.items():
    print(t[0] + ":", unicode_normalize(t[1]))

"""Вариант 4. Изменение отдельных метаданных путем прямого обращения к тегам с перекодированием"""

from pdfrw import PdfReader, PdfWriter, PdfDict
import unicodedata

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

def unicode_normalize(s):
    return unicodedata.normalize('NFKD', s).encode('ascii', 'ignore')

trailer = PdfReader(filename1)

# this statement is breaking pdfrw
trailer.Info.Creator = unicode_normalize(trailer.Info.Creator.decode())
trailer.Info.Title = "who am i"
print(trailer.Info)

# also have tried:
#trailer.Info.Title = PdfString(unicode_normalize(trailer.Info.Title))

PdfWriter(filename3, trailer=trailer).write()

"""Вариант 5. Изменение всех метаданных путем перезаписи всех метаданных, в том числе и неизмененных"""

from pdfrw import PdfReader, PdfWriter, PdfDict, IndirectPdfDict
import unicodedata

filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

writer = PdfWriter()

reader = PdfReader(filename1)
writer.addpages(reader.pages)
        
writer.trailer.Info = IndirectPdfDict(
    Title='Combined PDF Title',
    Author='Michael Driscoll',
    Subject='PDF Combinations',
    Creator='The Concatenator'
)
        
writer.write(filename3)

"""Вариант 6. Изменение метаданных путем обновления отдельных метаданных"""

from pdfrw import PdfReader, PdfWriter, PdfDict
 
filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'

trailer = PdfReader(filename1)
metadata = PdfDict(Title='nahoy', Subject='ooooooooo')
trailer.Info.update(metadata)
PdfWriter().write(filename1, trailer)

"""Вариант 7. Изменение метаданных путем добавления новых метаданных"""

from pdfrw import PdfReader, PdfWriter   
 
filename1 = "C:/Users/stece/Downloads/mets_overview_rus.pdf"
filename2 = "C:/Users/stece/Downloads/tsifrovye-sledy-naznachenie-i-proizvodstvo-ekspertiz.pdf"
filename3 = 'C:/Users/stece/Downloads/new.pdf'
  
trailer = PdfReader(filename1)    
trailer.Info.WhoAmI = "Tarun Lalwani"    
PdfWriter(filename1, trailer=trailer).write()

"""#### 5. Текстовые файлы

##### Textpipe: подходит для текстовых файлов

Данная библиотека не функционирует

#### 6. Архивы

##### Zipfile: подходит для архивов (zip, rar, 7z)

Данная библиотека имеет встроенный инструмент:
*	infolist: извлечение всех метаданных внутри файла

Был выведен только 1 вариант извлечения метаданных, но с группированием

Вариант 1. Извлечение как всех, так и отдельных метаданных путем прямого обращения к тегам
"""

import datetime
from xml.etree import ElementTree as etree
import zipfile

filename = "C:/Users/stece/Downloads/DataScienceTools-master.zip"

print(zipfile.is_zipfile(filename))
if (zipfile.is_zipfile(filename)):
    zfile = zipfile.ZipFile(filename)

    for key in zfile.infolist():
        print("ZipFileName:", key.filename)
        print("ZipOrigName:", key.orig_filename)
        print("ZipRequiredVersion:", key.extract_version)
        print("ZipBitFlag:", key.flag_bits)
        print("ZipCompression:", key.compress_type)
        print("ZipFileMode:", key.reserved)
        print("ZipModifyDate:", datetime.datetime(*key.date_time))
        print("ZipCreateSystem:", key.create_system)
        print("ZipCRC:", key.CRC)
        print("ZipCompressedSize:", key.compress_size)
        print("ZipComments:", key.comment)
        print("ZIP version:", key.create_version)
    
    #print(zfile.namelist())
    #print(zfile.infolist())

"""#### 7. Офисные документы

##### xml.etree.ElementTree: подходит для офисных документов (xml, xls, xlsx, csv, doc, docx, ppt, pptx)

Данная библиотека работает совместно с Zipfile и имеет два встроенных инструмента:
*	fromstring: парсит XML-файл для получения доступа к метаданным
*	getchildren: получает доступ к элементам метаданных

Был выведен только 1 вариант извлечения метаданных, но с группированием

Вариант 1. Извлечение всех метаданных путем поиска по названию тега
"""

from datetime import datetime as dt
from xml.etree import ElementTree as etree
import zipfile

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = "C:/Users/stece/Downloads/ABD_Project_Prez.pptx"
filename3 = "C:/Users/stece/Downloads/er.xlsx"
filename4 = "C:/Users/stece/Downloads/googleplaystore.csv"
filename5 = "C:/Users/stece/Downloads/DataScienceTools-master.zip"

isCore = False
isApp = False

print(zipfile.is_zipfile(filename3))
if (zipfile.is_zipfile(filename3)):
    zfile = zipfile.ZipFile(filename3)
    for i in zfile.namelist():
        print(i)
        if (i == 'docProps/core.xml'):
            isCore = True
        if (i == 'docProps/app.xml'):
            isApp = True
    print('isCore =', isCore)
    print('isApp =', isApp)
    #print(zfile.namelist())
    #print(zfile.infolist())
    if (isCore):
        core_xml = etree.fromstring(zfile  .read('docProps/core.xml'))
        core_mapping = {
        'title': 'Title',
        'subject': 'Subject',
        'creator': 'Author(s)',
        'keywords': 'Keywords',
        'description': 'Description',
        'lastModifiedBy': 'Last Modified By',
        'modified': 'Modified Date',
        'created': 'Created Date',
        'category': 'Category',
        'contentStatus': 'Status',
        'revision': 'Revision'
        }

        for element in core_xml.getchildren():
            for key, title in core_mapping.items():
                if key in element.tag:
                    if 'date' in title.lower():
                        text = dt.strptime(element.text, "%Y-%m-%dT%H:%M:%SZ")
                    else:
                        text = element.text
                    print("{}: {}".format(title, text))
    if (isApp):
        app_xml = etree.fromstring(zfile.read('docProps/app.xml'))
        app_mapping = {
        'TotalTime': 'Edit Time (minutes)',
        'Pages': 'Page Count',
        'Words': 'Word Count',
        'Characters': 'Character Count',
        'Lines': 'Line Count',
        'Paragraphs': 'Paragraph Count',
        'Company': 'Company',
        'HyperlinkBase': 'Hyperlink Base',
        'Slides': 'Slide count',
        'Notes': 'Note Count',
        'HiddenSlides': 'Hidden Slide Count',
        }
        for element in app_xml.getchildren():
            for key, title in app_mapping.items():
                if key in element.tag:
                    if 'date' in title.lower():
                        text = dt.strptime(element.text, "%Y-%m-%dT%H:%M:%SZ")
                    else:
                        text = element.text
                    print("{}: {}".format(title, text))

    zfile.close()

"""##### Zipfile: подходит для офисных документов (xls, xlsx, csv, doc, docx, ppt, pptx)

Данная библиотека имеет встроенный инструмент:
*	infolist: извлечение всех метаданных внутри файла

Был выведен только 1 вариант извлечения метаданных, но с группированием

Вариант 1. Извлечение как всех, так и отдельных метаданных путем прямого обращения к тегам
"""

import datetime
from xml.etree import ElementTree as etree
import zipfile

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = "C:/Users/stece/Downloads/ABD_Project_Prez.pptx"
filename3 = "C:/Users/stece/Downloads/er.xlsx"
filename4 = "C:/Users/stece/Downloads/googleplaystore.csv"
filename5 = "C:/Users/stece/Downloads/DataScienceTools-master.zip"

isCore = False
isApp = False

print(zipfile.is_zipfile(filename3))
if (zipfile.is_zipfile(filename3)):
    zfile = zipfile.ZipFile(filename3)

    for key in zfile.infolist():
        print("ZipFileName:", key.filename)
        print("ZipOrigName:", key.orig_filename)
        print("ZipRequiredVersion:", key.extract_version)
        print("ZipBitFlag:", key.flag_bits)
        print("ZipCompression:", key.compress_type)
        print("ZipFileMode:", key.reserved)
        print("ZipModifyDate:", datetime.datetime(*key.date_time))
        print("ZipCreateSystem:", key.create_system)
        print("ZipCRC:", key.CRC)
        print("ZipCompressedSize:", key.compress_size)
        print("ZipComments:", key.comment)
        print("ZIP version:", key.create_version)
    
    #print(zfile.namelist())
    #print(zfile.infolist())

"""##### Lxml: подходит для офисных документов

Данная библиотека значительно расширяет API ElementTree

##### Docx: подходит для офисных документов (doc, docx)

Данная библиотека имеет встроенный инструмент:

*	core_properties: извлечение основных (пользовательских) метаданных

Было выведено 2 варианта извлечения и 1 вариант изменения метаданных, но без группирования

Вариант 1. Извлечение отдельных метаданных путем прямого обращения к тегам
"""

import docx

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = 'C:/Users/stece/Downloads/new.docx'

doc = docx.Document(filename1)
properties = doc.core_properties

print('Автор документа:', properties.author)
print('Автор последней правки:', properties.last_modified_by)
print('Дата создания документа:', properties.created)
print('Дата последней правки:', properties.modified)
print('Дата последней печати:', properties.last_printed)
print('Количество сохранений:', properties.revision)

"""Вариант 2. Извлечение всех метаданных путем прямого обращения к тегам по названию"""

import docx

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = 'C:/Users/stece/Downloads/new.docx'

def getMetaData(doc):
    metadata = {}
    prop = doc.core_properties
    metadata["author"] = prop.author
    metadata["category"] = prop.category
    metadata["comments"] = prop.comments
    metadata["content_status"] = prop.content_status
    metadata["created"] = prop.created
    metadata["identifier"] = prop.identifier
    metadata["keywords"] = prop.keywords
    metadata["language"] = prop.language
    metadata["last modified"] = prop.last_modified_by
    metadata["last printed"] = prop.last_printed
    metadata["modified"] = prop.modified
    metadata["revision"] = prop.revision
    metadata["subject"] = prop.subject
    metadata["title"] = prop.title
    metadata["version"] = prop.version
    return metadata

doc = docx.Document(filename1)
metadata_dict = getMetaData(doc)
print(metadata_dict.keys())
print(metadata_dict.values())
print(metadata_dict.items())

for t in metadata_dict.items():
    print(t[0] + ":", t[1])

"""Вариант 3. Изменение отдельных метаданных путем прямого обращения к тегам"""

import docx

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = 'C:/Users/stece/Downloads/new.docx'

doc = docx.Document(filename1)
properties = doc.core_properties

properties.category = 'Brian'
doc.save(filename1)

"""##### Docx2python: подходит для офисных документов (doc, docx)

Данная библиотека имеет встроенный инструмент:

*	properties: извлечение основных (пользовательских) метаданных

Было выведено только 2 варианта извлечения метаданных, но без группирования

Вариант 1. Извлечение отдельных метаданных путем прямого обращения к тегам по названию
"""

from docx2python import docx2python

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = 'C:/Users/stece/Downloads/new.docx'

doc = docx2python(filename1)
prop = doc.properties

print(prop)
prop['title'] = "whoami"
print(prop['title'])
print(prop['subject'])
print(prop['creator'])
print(prop['keywords'])
print(prop['description'])
print(prop['lastModifiedBy'])
print(prop['revision'])
print(prop['created'])
print(prop['modified'])
print(prop['category'])

"""Вариант 2. Извлечение всех метаданных"""

from docx2python import docx2python

filename1 = "C:/Users/stece/Downloads/Metadannye (2).docx"
filename2 = 'C:/Users/stece/Downloads/new.docx'

doc = docx2python(filename1)
prop = doc.properties

print(prop)
print(prop['title'])
print(prop.items())
print(prop.keys())
print(prop.values())

for t in prop.items():
    print(t[0] + ":", t[1])

"""##### Pptx: подходит для офисных документов (ppt, pptx)

Данная библиотека имеет встроенный инструмент:

*	core_properties: извлечение основных (пользовательских) метаданных

Было выведено 2 варианта извлечения и 1 вариант изменения метаданных, но без группирования

Вариант 1. Извлечение отдельных метаданных путем прямого обращения к тегам
"""

import pptx

filename = "C:/Users/stece/Downloads/ABD_Project_Prez.pptx"

ppt = pptx.Presentation(filename)
properties = ppt.core_properties

print('Автор документа:', properties.author)
print('Автор последней правки:', properties.last_modified_by)
print('Дата создания документа:', properties.created)
print('Дата последней правки:', properties.modified)
print('Дата последней печати:', properties.last_printed)
print('Количество сохранений:', properties.revision)

"""Вариант 2. Извлечение всех метаданных путем прямого обращения к тегам по названию"""

import pptx

filename = "C:/Users/stece/Downloads/ABD_Project_Prez.pptx"

def getMetaData(ppt):
    metadata = {}
    prop = ppt.core_properties
    metadata["author"] = prop.author
    metadata["category"] = prop.category
    metadata["comments"] = prop.comments
    metadata["content_status"] = prop.content_status
    metadata["created"] = prop.created
    metadata["identifier"] = prop.identifier
    metadata["keywords"] = prop.keywords
    metadata["language"] = prop.language
    metadata["last modified"] = prop.last_modified_by
    metadata["last printed"] = prop.last_printed
    metadata["modified"] = prop.modified
    metadata["revision"] = prop.revision
    metadata["subject"] = prop.subject
    metadata["title"] = prop.title
    metadata["version"] = prop.version
    return metadata

ppt = pptx.Presentation(filename)
metadata_dict = getMetaData(ppt)
print(metadata_dict.keys())
print(metadata_dict.values())
print(metadata_dict.items())

for t in metadata_dict.items():
    print(t[0] + ":", t[1])

"""Вариант 3. Изменение отдельных метаданных путем прямого обращения к тегам"""

import pptx

filename = "C:/Users/stece/Downloads/ABD_Project_Prez.pptx"

ppt = pptx.Presentation(filename)
properties = ppt.core_properties

properties.category = 'Brian'
ppt.save(filename)

"""##### Pyexcel: подходит для офисных документов (xls, xlsx, csv)

Данная библиотека работает с таблицами Excel

##### Openpyxl: подходит для офисных документов (xls, xlsx, csv)

Данная библиотека имеет встроенный инструмент:

*	properties: извлечение основных (пользовательских) метаданных

Было выведено 2 варианта извлечения и 1 вариант изменения метаданных, но без группирования

Вариант 1. Извлечение отдельных метаданных путем прямого обращения к тегам
"""

from openpyxl import load_workbook

filename1 = "C:/Users/stece/Downloads/er.xlsx"
filename2 = "C:/Users/stece/Downloads/googleplaystore.csv"

wb = load_workbook(filename1)
prop = wb.properties

print('Автор документа:', prop.creator)
print('Автор последней правки:', prop.last_modified_by)
print('Дата создания документа:', prop.created)
print('Дата последней правки:', prop.modified)
print('Дата последней печати:', prop.lastPrinted)
print('Количество сохранений:', prop.revision)

"""Вариант 2. Извлечение всех метаданных путем прямого обращения к тегам по названию"""

from openpyxl import load_workbook

filename1 = "C:/Users/stece/Downloads/er.xlsx"
filename2 = "C:/Users/stece/Downloads/googleplaystore.csv"

def getMetaData(wb):
    metadata = {}
    prop = wb.properties
    metadata["creator"] = prop.creator
    metadata["title"] = prop.title
    metadata["description"] = prop.description
    metadata["subject"] = prop.subject
    metadata["identifier"] = prop.identifier
    metadata["language"] = prop.language
    metadata["created"] = prop.created
    metadata["modified"] = prop.modified
    metadata["lastModifiedBy="] = prop.lastModifiedBy
    metadata["category"] = prop.category
    metadata["contentStatus"] = prop.contentStatus
    metadata["version"] = prop.version
    metadata["revision"] = prop.revision
    metadata["keywords"] = prop.keywords
    metadata["lastPrinted"] = prop.lastPrinted
    return metadata

wb = load_workbook(filename1)
metadata_dict = getMetaData(wb)
print(metadata_dict.keys())
print(metadata_dict.values())
print(metadata_dict.items())

for t in metadata_dict.items():
    print(t[0] + ":", t[1])

"""Вариант 3. Изменение отдельных метаданных путем прямого обращения к тегам"""

from openpyxl import load_workbook

filename1 = "C:/Users/stece/Downloads/er.xlsx"
filename2 = "C:/Users/stece/Downloads/googleplaystore.csv"

wb = load_workbook(filename1)
prop = wb.properties

prop.creator = "Андрюха"
wb.save(filename1)

"""##### XlsxWriter: подходит для офисных документов (xls, xlsx, csv)

Данная библиотека создает Excel-файлы и может в них записывать собственные метаданные

Имеется только 1 вариант изменения метаданных
"""

import xlsxwriter

filename1 = "C:/Users/stece/Downloads/er.xlsx"
filename2 = "C:/Users/stece/Downloads/googleplaystore.csv"

workbook = xlsxwriter.Workbook(filename1)
worksheet = workbook.add_worksheet()

workbook.set_properties({
    'title':    'This is an example spreadsheet',
    'subject':  'With document properties',
    'author':   'John McNamara',
    'manager':  'Dr. Heinz Doofenshmirtz',
    'company':  'of Wolves',
    'category': 'Example spreadsheets',
    'keywords': 'Sample, Example, Properties',
    'comments': 'Created with Python and XlsxWriter',
    'status':   'Quo',
})

#worksheet.set_column('A:A', 70)
#worksheet.write('A1', "Select 'Workbook Properties' to see properties.")

workbook.close()

"""##### Pymetadata: подходит для офисных документов (pdf, xls, xlsx, csv, doc, docx, ppt, pptx)

Данная библиотека работает совместно с программой exiftools

##### File-metadata: подходит для офисных документов

Данная библиотека работает совместно с программой exiftools

##### Olemeta: подходит для офисных документов

Данная библиотека считается самой свежой и к тому же 2020 года, но выдает ошибки при компиляции

##### OleFileIO_PL: подходит для офисных документов

Данная библиотека считается устаревшей, не функционирует

#### 8. Исполнительные файлы

##### Pefile: подходит для исполнительных файлов (exe, dll)

Данная библиотека считается относительно свежей, не функционирует
"""